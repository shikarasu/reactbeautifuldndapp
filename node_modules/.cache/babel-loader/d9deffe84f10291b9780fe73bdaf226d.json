{"ast":null,"code":"import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nexport * from \"./types.js\";\nexport * from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers([].concat(state.options.modifiers.filter(function (modifier) {\n          return !defaultModifiers.find(function (_ref) {\n            var name = _ref.name;\n            return name === modifier.name;\n          });\n        }), defaultModifiers.map(function (defaultModifier) {\n          return Object.assign({}, defaultModifier, {}, state.options.modifiers.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === defaultModifier.name;\n          }));\n        }))); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref3) {\n            var name = _ref3.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = orderedModifiers.find(function (_ref4) {\n              var name = _ref4.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        } // Strip out disabled modifiers\n\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref5) {\n        var name = _ref5.name,\n            _ref5$options = _ref5.options,\n            options = _ref5$options === void 0 ? {} : _ref5$options,\n            effect = _ref5.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper =\n/*#__PURE__*/\npopperGenerator();","map":{"version":3,"sources":["C:/Code Projects/task-app/node_modules/@popperjs/core/lib/index.js"],"names":["getCompositeRect","getLayoutRect","listScrollParents","getOffsetParent","getComputedStyle","orderModifiers","debounce","validateModifiers","uniqueBy","getBasePlacement","isElement","auto","INVALID_ELEMENT_ERROR","INFINITE_LOOP_ERROR","DEFAULT_OPTIONS","placement","modifiers","strategy","areValidElements","_len","arguments","length","args","Array","_key","some","element","getBoundingClientRect","popperGenerator","generatorOptions","_generatorOptions","_generatorOptions$def","defaultModifiers","_generatorOptions$def2","defaultOptions","createPopper","reference","popper","options","state","orderedModifiers","Object","assign","modifiersData","elements","attributes","styles","effectCleanupFns","isDestroyed","instance","setOptions","cleanupModifierEffects","scrollParents","concat","filter","modifier","find","_ref","name","map","defaultModifier","_ref2","process","env","NODE_ENV","_ref3","flipModifier","_ref4","console","error","join","_getComputedStyle","marginTop","marginRight","marginBottom","marginLeft","margin","parseFloat","warn","m","enabled","runModifierEffects","update","forceUpdate","_state$elements","rects","reset","forEach","data","__debug_loops__","index","_state$orderedModifie","fn","_state$orderedModifie2","_options","Promise","resolve","destroy","then","onFirstUpdate","_ref5","_ref5$options","effect","cleanupFn","noopFn","push"],"mappings":"AAAA,OAAOA,gBAAP,MAA6B,iCAA7B;AACA,OAAOC,aAAP,MAA0B,8BAA1B;AACA,OAAOC,iBAAP,MAA8B,kCAA9B;AACA,OAAOC,eAAP,MAA4B,gCAA5B;AACA,OAAOC,gBAAP,MAA6B,iCAA7B;AACA,OAAOC,cAAP,MAA2B,2BAA3B;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAOC,iBAAP,MAA8B,8BAA9B;AACA,OAAOC,QAAP,MAAqB,qBAArB;AACA,OAAOC,gBAAP,MAA6B,6BAA7B;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,IAAT,QAAqB,YAArB;AACA,cAAc,YAAd;AACA,cAAc,YAAd;AACA,IAAIC,qBAAqB,GAAG,6JAA5B;AACA,IAAIC,mBAAmB,GAAG,+HAA1B;AACA,IAAIC,eAAe,GAAG;AACpBC,EAAAA,SAAS,EAAE,QADS;AAEpBC,EAAAA,SAAS,EAAE,EAFS;AAGpBC,EAAAA,QAAQ,EAAE;AAHU,CAAtB;;AAMA,SAASC,gBAAT,GAA4B;AAC1B,OAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,IAAV,CAApC,EAAqDK,IAAI,GAAG,CAAjE,EAAoEA,IAAI,GAAGL,IAA3E,EAAiFK,IAAI,EAArF,EAAyF;AACvFF,IAAAA,IAAI,CAACE,IAAD,CAAJ,GAAaJ,SAAS,CAACI,IAAD,CAAtB;AACD;;AAED,SAAO,CAACF,IAAI,CAACG,IAAL,CAAU,UAAUC,OAAV,EAAmB;AACnC,WAAO,EAAEA,OAAO,IAAI,OAAOA,OAAO,CAACC,qBAAf,KAAyC,UAAtD,CAAP;AACD,GAFO,CAAR;AAGD;;AAED,OAAO,SAASC,eAAT,CAAyBC,gBAAzB,EAA2C;AAChD,MAAIA,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAC/BA,IAAAA,gBAAgB,GAAG,EAAnB;AACD;;AAED,MAAIC,iBAAiB,GAAGD,gBAAxB;AAAA,MACIE,qBAAqB,GAAGD,iBAAiB,CAACE,gBAD9C;AAAA,MAEIA,gBAAgB,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,EAAnC,GAAwCA,qBAF/D;AAAA,MAGIE,sBAAsB,GAAGH,iBAAiB,CAACI,cAH/C;AAAA,MAIIA,cAAc,GAAGD,sBAAsB,KAAK,KAAK,CAAhC,GAAoCnB,eAApC,GAAsDmB,sBAJ3E;AAKA,SAAO,SAASE,YAAT,CAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,OAAzC,EAAkD;AACvD,QAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtBA,MAAAA,OAAO,GAAGJ,cAAV;AACD;;AAED,QAAIK,KAAK,GAAG;AACVxB,MAAAA,SAAS,EAAE,QADD;AAEVyB,MAAAA,gBAAgB,EAAE,EAFR;AAGVF,MAAAA,OAAO,EAAEG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB5B,eAAlB,EAAmC,EAAnC,EAAuCoB,cAAvC,CAHC;AAIVS,MAAAA,aAAa,EAAE,EAJL;AAKVC,MAAAA,QAAQ,EAAE;AACRR,QAAAA,SAAS,EAAEA,SADH;AAERC,QAAAA,MAAM,EAAEA;AAFA,OALA;AASVQ,MAAAA,UAAU,EAAE,EATF;AAUVC,MAAAA,MAAM,EAAE;AAVE,KAAZ;AAYA,QAAIC,gBAAgB,GAAG,EAAvB;AACA,QAAIC,WAAW,GAAG,KAAlB;AACA,QAAIC,QAAQ,GAAG;AACbV,MAAAA,KAAK,EAAEA,KADM;AAEbW,MAAAA,UAAU,EAAE,SAASA,UAAT,CAAoBZ,OAApB,EAA6B;AACvCa,QAAAA,sBAAsB;AACtBZ,QAAAA,KAAK,CAACD,OAAN,GAAgBG,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBR,cAAlB,EAAkC,EAAlC,EAAsCK,KAAK,CAACD,OAA5C,EAAqD,EAArD,EAAyDA,OAAzD,CAAhB;AACAC,QAAAA,KAAK,CAACa,aAAN,GAAsB;AACpBhB,UAAAA,SAAS,EAAE1B,SAAS,CAAC0B,SAAD,CAAT,GAAuBlC,iBAAiB,CAACkC,SAAD,CAAxC,GAAsD,EAD7C;AAEpBC,UAAAA,MAAM,EAAEnC,iBAAiB,CAACmC,MAAD;AAFL,SAAtB,CAHuC,CAMpC;AACH;;AAEA,YAAIG,gBAAgB,GAAGnC,cAAc,CAAC,GAAGgD,MAAH,CAAUd,KAAK,CAACD,OAAN,CAActB,SAAd,CAAwBsC,MAAxB,CAA+B,UAAUC,QAAV,EAAoB;AACjG,iBAAO,CAACvB,gBAAgB,CAACwB,IAAjB,CAAsB,UAAUC,IAAV,EAAgB;AAC5C,gBAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AACA,mBAAOA,IAAI,KAAKH,QAAQ,CAACG,IAAzB;AACD,WAHO,CAAR;AAID,SAL+C,CAAV,EAKlC1B,gBAAgB,CAAC2B,GAAjB,CAAqB,UAAUC,eAAV,EAA2B;AAClD,iBAAOnB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBkB,eAAlB,EAAmC,EAAnC,EAAuCrB,KAAK,CAACD,OAAN,CAActB,SAAd,CAAwBwC,IAAxB,CAA6B,UAAUK,KAAV,EAAiB;AAC1F,gBAAIH,IAAI,GAAGG,KAAK,CAACH,IAAjB;AACA,mBAAOA,IAAI,KAAKE,eAAe,CAACF,IAAhC;AACD,WAH6C,CAAvC,CAAP;AAID,SALG,CALkC,CAAD,CAArC,CATuC,CAmBjC;AACN;;AAEA,YAAII,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,cAAIhD,SAAS,GAAGR,QAAQ,CAAC,GAAG6C,MAAH,CAAUb,gBAAV,EAA4BD,KAAK,CAACD,OAAN,CAActB,SAA1C,CAAD,EAAuD,UAAUiD,KAAV,EAAiB;AAC9F,gBAAIP,IAAI,GAAGO,KAAK,CAACP,IAAjB;AACA,mBAAOA,IAAP;AACD,WAHuB,CAAxB;AAIAnD,UAAAA,iBAAiB,CAACS,SAAD,CAAjB;;AAEA,cAAIP,gBAAgB,CAAC8B,KAAK,CAACD,OAAN,CAAcvB,SAAf,CAAhB,KAA8CJ,IAAlD,EAAwD;AACtD,gBAAIuD,YAAY,GAAG1B,gBAAgB,CAACgB,IAAjB,CAAsB,UAAUW,KAAV,EAAiB;AACxD,kBAAIT,IAAI,GAAGS,KAAK,CAACT,IAAjB;AACA,qBAAOA,IAAI,KAAK,MAAhB;AACD,aAHkB,CAAnB;;AAKA,gBAAI,CAACQ,YAAL,EAAmB;AACjBE,cAAAA,OAAO,CAACC,KAAR,CAAc,CAAC,0DAAD,EAA6D,8BAA7D,EAA6FC,IAA7F,CAAkG,GAAlG,CAAd;AACD;AACF;;AAED,cAAIC,iBAAiB,GAAGnE,gBAAgB,CAACiC,MAAD,CAAxC;AAAA,cACImC,SAAS,GAAGD,iBAAiB,CAACC,SADlC;AAAA,cAEIC,WAAW,GAAGF,iBAAiB,CAACE,WAFpC;AAAA,cAGIC,YAAY,GAAGH,iBAAiB,CAACG,YAHrC;AAAA,cAIIC,UAAU,GAAGJ,iBAAiB,CAACI,UAJnC,CAlByC,CAsBM;AAC/C;;;AAGA,cAAI,CAACH,SAAD,EAAYC,WAAZ,EAAyBC,YAAzB,EAAuCC,UAAvC,EAAmDlD,IAAnD,CAAwD,UAAUmD,MAAV,EAAkB;AAC5E,mBAAOC,UAAU,CAACD,MAAD,CAAjB;AACD,WAFG,CAAJ,EAEI;AACFR,YAAAA,OAAO,CAACU,IAAR,CAAa,CAAC,6DAAD,EAAgE,2DAAhE,EAA6H,4DAA7H,EAA2L,0DAA3L,EAAuP,YAAvP,EAAqQR,IAArQ,CAA0Q,GAA1Q,CAAb;AACD;AACF,SArDsC,CAqDrC;;;AAGF/B,QAAAA,KAAK,CAACC,gBAAN,GAAyBA,gBAAgB,CAACc,MAAjB,CAAwB,UAAUyB,CAAV,EAAa;AAC5D,iBAAOA,CAAC,CAACC,OAAT;AACD,SAFwB,CAAzB;AAGAC,QAAAA,kBAAkB;AAClB,eAAOhC,QAAQ,CAACiC,MAAT,EAAP;AACD,OA/DY;AAgEb;AACA;AACA;AACA;AACA;AACAC,MAAAA,WAAW,EAAE,SAASA,WAAT,GAAuB;AAClC,YAAInC,WAAJ,EAAiB;AACf;AACD;;AAED,YAAIoC,eAAe,GAAG7C,KAAK,CAACK,QAA5B;AAAA,YACIR,SAAS,GAAGgD,eAAe,CAAChD,SADhC;AAAA,YAEIC,MAAM,GAAG+C,eAAe,CAAC/C,MAF7B,CALkC,CAOG;AACrC;;AAEA,YAAI,CAACnB,gBAAgB,CAACkB,SAAD,EAAYC,MAAZ,CAArB,EAA0C;AACxC,cAAIyB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCI,YAAAA,OAAO,CAACC,KAAR,CAAczD,qBAAd;AACD;;AAED;AACD,SAhBiC,CAgBhC;;;AAGF2B,QAAAA,KAAK,CAAC8C,KAAN,GAAc;AACZjD,UAAAA,SAAS,EAAEpC,gBAAgB,CAACoC,SAAD,EAAYjC,eAAe,CAACkC,MAAD,CAA3B,EAAqCE,KAAK,CAACD,OAAN,CAAcrB,QAAd,KAA2B,OAAhE,CADf;AAEZoB,UAAAA,MAAM,EAAEpC,aAAa,CAACoC,MAAD;AAFT,SAAd,CAnBkC,CAsB/B;AACH;AACA;AACA;AACA;;AAEAE,QAAAA,KAAK,CAAC+C,KAAN,GAAc,KAAd;AACA/C,QAAAA,KAAK,CAACxB,SAAN,GAAkBwB,KAAK,CAACD,OAAN,CAAcvB,SAAhC,CA7BkC,CA6BS;AAC3C;AACA;AACA;;AAEAwB,QAAAA,KAAK,CAACC,gBAAN,CAAuB+C,OAAvB,CAA+B,UAAUhC,QAAV,EAAoB;AACjD,iBAAOhB,KAAK,CAACI,aAAN,CAAoBY,QAAQ,CAACG,IAA7B,IAAqCjB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBa,QAAQ,CAACiC,IAA3B,CAA5C;AACD,SAFD;AAGA,YAAIC,eAAe,GAAG,CAAtB;;AAEA,aAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGnD,KAAK,CAACC,gBAAN,CAAuBnB,MAAnD,EAA2DqE,KAAK,EAAhE,EAAoE;AAClE,cAAI5B,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCyB,YAAAA,eAAe,IAAI,CAAnB;;AAEA,gBAAIA,eAAe,GAAG,GAAtB,EAA2B;AACzBrB,cAAAA,OAAO,CAACC,KAAR,CAAcxD,mBAAd;AACA;AACD;AACF;;AAED,cAAI0B,KAAK,CAAC+C,KAAN,KAAgB,IAApB,EAA0B;AACxB/C,YAAAA,KAAK,CAAC+C,KAAN,GAAc,KAAd;AACAI,YAAAA,KAAK,GAAG,CAAC,CAAT;AACA;AACD;;AAED,cAAIC,qBAAqB,GAAGpD,KAAK,CAACC,gBAAN,CAAuBkD,KAAvB,CAA5B;AAAA,cACIE,EAAE,GAAGD,qBAAqB,CAACC,EAD/B;AAAA,cAEIC,sBAAsB,GAAGF,qBAAqB,CAACrD,OAFnD;AAAA,cAGIwD,QAAQ,GAAGD,sBAAsB,KAAK,KAAK,CAAhC,GAAoC,EAApC,GAAyCA,sBAHxD;AAAA,cAIInC,IAAI,GAAGiC,qBAAqB,CAACjC,IAJjC;;AAMA,cAAI,OAAOkC,EAAP,KAAc,UAAlB,EAA8B;AAC5BrD,YAAAA,KAAK,GAAGqD,EAAE,CAAC;AACTrD,cAAAA,KAAK,EAAEA,KADE;AAETD,cAAAA,OAAO,EAAEwD,QAFA;AAGTpC,cAAAA,IAAI,EAAEA,IAHG;AAITT,cAAAA,QAAQ,EAAEA;AAJD,aAAD,CAAF,IAKFV,KALN;AAMD;AACF;AACF,OA3IY;AA4Ib;AACA;AACA2C,MAAAA,MAAM,EAAE5E,QAAQ,CAAC,YAAY;AAC3B,eAAO,IAAIyF,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpC/C,UAAAA,QAAQ,CAACkC,WAAT;AACAa,UAAAA,OAAO,CAACzD,KAAD,CAAP;AACD,SAHM,CAAP;AAID,OALe,CA9IH;AAoJb0D,MAAAA,OAAO,EAAE,SAASA,OAAT,GAAmB;AAC1B9C,QAAAA,sBAAsB;AACtBH,QAAAA,WAAW,GAAG,IAAd;AACD;AAvJY,KAAf;;AA0JA,QAAI,CAAC9B,gBAAgB,CAACkB,SAAD,EAAYC,MAAZ,CAArB,EAA0C;AACxC,UAAIyB,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCI,QAAAA,OAAO,CAACC,KAAR,CAAczD,qBAAd;AACD;;AAED,aAAOqC,QAAP;AACD;;AAEDA,IAAAA,QAAQ,CAACC,UAAT,CAAoBZ,OAApB,EAA6B4D,IAA7B,CAAkC,UAAU3D,KAAV,EAAiB;AACjD,UAAI,CAACS,WAAD,IAAgBV,OAAO,CAAC6D,aAA5B,EAA2C;AACzC7D,QAAAA,OAAO,CAAC6D,aAAR,CAAsB5D,KAAtB;AACD;AACF,KAJD,EArLuD,CAyLnD;AACJ;AACA;AACA;AACA;;AAEA,aAAS0C,kBAAT,GAA8B;AAC5B1C,MAAAA,KAAK,CAACC,gBAAN,CAAuB+C,OAAvB,CAA+B,UAAUa,KAAV,EAAiB;AAC9C,YAAI1C,IAAI,GAAG0C,KAAK,CAAC1C,IAAjB;AAAA,YACI2C,aAAa,GAAGD,KAAK,CAAC9D,OAD1B;AAAA,YAEIA,OAAO,GAAG+D,aAAa,KAAK,KAAK,CAAvB,GAA2B,EAA3B,GAAgCA,aAF9C;AAAA,YAGIC,MAAM,GAAGF,KAAK,CAACE,MAHnB;;AAKA,YAAI,OAAOA,MAAP,KAAkB,UAAtB,EAAkC;AAChC,cAAIC,SAAS,GAAGD,MAAM,CAAC;AACrB/D,YAAAA,KAAK,EAAEA,KADc;AAErBmB,YAAAA,IAAI,EAAEA,IAFe;AAGrBT,YAAAA,QAAQ,EAAEA,QAHW;AAIrBX,YAAAA,OAAO,EAAEA;AAJY,WAAD,CAAtB;;AAOA,cAAIkE,MAAM,GAAG,SAASA,MAAT,GAAkB,CAAE,CAAjC;;AAEAzD,UAAAA,gBAAgB,CAAC0D,IAAjB,CAAsBF,SAAS,IAAIC,MAAnC;AACD;AACF,OAlBD;AAmBD;;AAED,aAASrD,sBAAT,GAAkC;AAChCJ,MAAAA,gBAAgB,CAACwC,OAAjB,CAAyB,UAAUK,EAAV,EAAc;AACrC,eAAOA,EAAE,EAAT;AACD,OAFD;AAGA7C,MAAAA,gBAAgB,GAAG,EAAnB;AACD;;AAED,WAAOE,QAAP;AACD,GA7ND;AA8ND;AACD,OAAO,IAAId,YAAY;AACvB;AACAP,eAAe,EAFR","sourcesContent":["import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport getComputedStyle from \"./dom-utils/getComputedStyle.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport validateModifiers from \"./utils/validateModifiers.js\";\nimport uniqueBy from \"./utils/uniqueBy.js\";\nimport getBasePlacement from \"./utils/getBasePlacement.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nimport { auto } from \"./enums.js\";\nexport * from \"./types.js\";\nexport * from \"./enums.js\";\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers([].concat(state.options.modifiers.filter(function (modifier) {\n          return !defaultModifiers.find(function (_ref) {\n            var name = _ref.name;\n            return name === modifier.name;\n          });\n        }), defaultModifiers.map(function (defaultModifier) {\n          return Object.assign({}, defaultModifier, {}, state.options.modifiers.find(function (_ref2) {\n            var name = _ref2.name;\n            return name === defaultModifier.name;\n          }));\n        }))); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (process.env.NODE_ENV !== \"production\") {\n          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref3) {\n            var name = _ref3.name;\n            return name;\n          });\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            var flipModifier = orderedModifiers.find(function (_ref4) {\n              var name = _ref4.name;\n              return name === 'flip';\n            });\n\n            if (!flipModifier) {\n              console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', 'present and enabled to work.'].join(' '));\n            }\n          }\n\n          var _getComputedStyle = getComputedStyle(popper),\n              marginTop = _getComputedStyle.marginTop,\n              marginRight = _getComputedStyle.marginRight,\n              marginBottom = _getComputedStyle.marginBottom,\n              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n\n\n          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {\n            return parseFloat(margin);\n          })) {\n            console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));\n          }\n        } // Strip out disabled modifiers\n\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (process.env.NODE_ENV !== \"production\") {\n            __debug_loops__ += 1;\n\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref5) {\n        var name = _ref5.name,\n            _ref5$options = _ref5.options,\n            options = _ref5$options === void 0 ? {} : _ref5$options,\n            effect = _ref5.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper =\n/*#__PURE__*/\npopperGenerator();"]},"metadata":{},"sourceType":"module"}