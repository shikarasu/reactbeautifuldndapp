{"ast":null,"code":"import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport within from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, Math.abs(referenceRect[len] - arrowRect[len]), arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = state.modifiersData.popperOffsets[mainAxis] + minOffset - offsetModifierValue;\n    var tetherMax = state.modifiersData.popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    state.modifiersData.popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    state.modifiersData.popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","map":{"version":3,"sources":["C:/Code Projects/task-app/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js"],"names":["top","left","right","bottom","start","getBasePlacement","getMainAxisFromPlacement","getAltAxis","within","getLayoutRect","detectOverflow","getVariation","getFreshSideObject","preventOverflow","_ref","state","options","name","_options$mainAxis","mainAxis","checkMainAxis","_options$altAxis","altAxis","checkAltAxis","boundary","rootBoundary","padding","_options$tether","tether","_options$tetherOffset","tetherOffset","overflow","basePlacement","placement","variation","isBasePlacement","popperOffsets","modifiersData","referenceRect","rects","reference","popperRect","popper","tetherOffsetValue","Object","assign","data","x","y","mainSide","altSide","len","offset","min","max","additive","minLen","maxLen","arrowElement","elements","arrow","arrowRect","width","height","arrowPaddingObject","arrowPaddingMin","arrowPaddingMax","arrowLen","Math","abs","minOffset","maxOffset","offsetModifierValue","tetherMin","tetherMax","preventedOffset","_mainSide","_altSide","_offset","_min","_max","_preventedOffset","enabled","phase","fn","requiresIfExists"],"mappings":"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","sourcesContent":["import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport within from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, Math.abs(referenceRect[len] - arrowRect[len]), arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = state.modifiersData.popperOffsets[mainAxis] + minOffset - offsetModifierValue;\n    var tetherMax = state.modifiersData.popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    state.modifiersData.popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    state.modifiersData.popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n}\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};"]},"metadata":{},"sourceType":"module"}